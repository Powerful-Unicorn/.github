<!-- Template for PROJECT REPORT of CapstoneDesign 2024-2H, initially written by khyoo -->
<!-- 본 파일은 2024년도 컴공 졸업프로젝트의 <1차보고서> 작성을 위한 기본 양식입니다. -->
<!-- 아래에 "*"..."*" 표시는 italic체로 출력하기 위해서 사용한 것입니다. -->
<!-- "내용"에 해당하는 부분을 지우고, 여러분 과제의 내용을 작성해 주세요. -->

# Team-Info
| (1) 과제명 | Dietary Restrictions을 가진 외국인들을 위한 생성형 AI를 이용한 맞춤형 한식 정보 제공 채팅 앱 서비스 FoodieBuddy
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 11-힘찬유니콘 |
| (3) 팀 구성원 | 손민서 (2117020) : 리더, 백엔드<br> 도하연 (2117012) : 팀원, 프론트엔드<br> 정지후 (2117032) : 팀원, AI		 |
| (4) 팀 지도교수 | 이형준 교수님 |
| (5) 팀 멘토 | 이관호 / 연구원 / Samsung Advanced Institute of Technology (SAIT) |
| (6) 과제 분류 | 산학과제 |
| (6) 과제 키워드 | • Dietary restrictions (건강상의 이유, 문화적, 종교적 이유, 또는 개인적인 선호 등에 따라 특정 음식이나 영양소를 제한하는 것)<br> • 텍스트/이미지 생성형 AI<br> • 멀티모달  |
| (7) 과제 내용 요약 | FoodieBuddy는 한국에 머무르는 dietary restrictions이 있는 외국인들을 돕기 위한 채팅 기반 앱 서비스 입니다. FoodieBuddy는 언어 장벽과 낯선 한식 재료로 인한 어려움을 해결하고, 사용자의 dietary restrictions에 맞춘 맞춤형 메뉴 추천을 제공합니다. 이러한 기능을 구현하기 위해 gpt-4o를 이용하여 채팅을 진행하고 파인튜닝된 Stable Diffusion 모델을 이용하여 한식 메뉴 이미지를 생성합니다. FoodieBuddy를 통해 식단 정보에 대한 접근성을 높이고, 사용자가 본인에게 적합한 한식 메뉴를 선택하는 과정을 더욱 쉽게 만들고자 합니다. |

<br>

# Project-Summary
| 항목 | 내용 |
|:---  |---  |
| (1) 문제 정의 | <br>FoodieBuddy 개발에 앞서 정의한 문제와 FoodieBuddy가 그 문제를 해결하는 방식을, **target customer**, 그들이 겪는 **문제점**, 그 문제점을 세부적으로 나눈 **sub-problems(painpoints)**, 그 sub-problems를 해결하는 **solution(기능**)의 네 단계로 나누어 정리하고자 한다. <br><br>**1. Target customer:** <br>타겟층은 dietary restrictions을 가진, 한국에 머무르는 외국인들이다. 이들은 한식이 낯설고 한국어로 된 정보로의 접근이 어려운 상황에서 섭취할 수 있는 음식을 가려내야 하는 상황이다. <!--이를 바탕으로 페르소나는 프랑스 국적의 20대 여성인 소피아로 설정하였다. 소피아는 채식주의자이고 현재 교환학생으로 한국에 체류 중이다. 음식을 밖에서 사 먹어야 하는 상황이 생길 때, 재료 정보의 부족과 소통의 어려움으로 인해 음식점 선택과 메뉴 선택에 불편함을 겪고 있다. --> <br><br>**2. 문제점:** <br>Diertary restrictions을 가진, 한국에 머무르는 외국인들은 한식에 관한 지식과 정보가 부족하며 한국어로 된 정보에 접근하는 것과 음식점에서 의사소통하는 것에도 어려움이 있다.<br><br>**3. Sub-problems(painpoints):** <br>  • Problem a) 번역기만으로는 한식 메뉴명을 직관적으로 이해하기 어렵다. <br>  • Problem b) 다른 문화권의 사람들에겐 "밑반찬"의 존재와 종류가 낯설 수 있다. <br>  • Problem c) dietary restrictions이라는 제약까지 가진 상황에서 한정적인 정보를 가지고 한식 메뉴를 탐색하고 선택해야 한다.<br><br>**4. Solution(기능)**:<br>  • Solution1 (problem a+c 를 해결) 메뉴판 사진 설명 기능: 발음 기호와 함께, 의역된 표현으로 메뉴명을 안내한다. 사용자의 dietary restrictions와 관련된 내용은 특히 강조하여 나타낸다. <br>  • Solution2 (problem b+c 를 해결) 밑반찬 사진 설명: 밑반찬 사진을 업로드하면 그 밑반찬에 대한 설명을 제공한다. 또한, dietary restrictions에 해당하는 재료가 들어가는지 여부에 대한 정보를 안내한다. <br>  • Solution3 (problem c 를 해결) 한식메뉴 추천: 유저의 요청과 dietary restrictions 정보를 함께 고려하여 한식 메뉴를 추천한다. 이때 추천하는 메뉴에 대한 설명과 이미지를 함께 제공한다.<br><br>  |
| (2) 기존연구와의 비교 | <br>**1. 번역기 :** <br> 구글 번역이나 파파고 등의 번역기 서비스를 이용하면, 메뉴판에 영어 설명이 적혀 있지 않아도 손쉽게 번역을 할 수 있다는 장점이 있다. 하지만, 공기밥을 ‘Air rice’ 로 글자 그대로 오역하거나, 불고기를 ‘Bulgogi’ 라고 발음 그대로 번역하는 경우가 많다는 것이 단점이다. 이를 해결하기 위해 본 프로젝트는 메뉴명을 ‘Barbequed beef’ 와 같이 의역하여 메뉴명 만으로도 무슨 재료를 사용한 음식인지 쉽게 알 수 있도록 한다. 또한, 간단한 설명을 덧붙여 추가적인 정보를 제공한다.<br><br>**2. AllergyEats :** <br> 미국 내 알레르기 친화적인 레스토랑을 안내하는 가이드 앱이다. 장점은 알레르기 및 dietary restrictions 에 맞게 검색 결과를 맞춤 설정할 수 있다는 것이다. 하지만, 미국의 일부 도시만 지원한다는 것이 단점이다. 또한, 해당 서비스는 dietary restrictions 으로 지정된 10가지 재료 안에서만 선택할 수 있다. 본 프로젝트는 AllergyEats 와 다르게 한국에서 사용할 수 있다. 또한, dietary restriction을 직접 입력하는 기능도 있어 더 많은 사용자를 포괄할 수 있다.<br><br>  |
| (3) 제안 내용 |<br> **1.** gpt-4o를 활용한 메뉴판 사진의 메뉴명 인식 및 설명 채팅 <br> **2.** gpt-4o를 활용한 밑반찬 사진 인식 및 설명 채팅<br> **3.** gpt-4o를 활용한 dietary restrictions 기반 한식 추천 채팅<br> **4.** 파인튜닝된 Stable Diffusion 모델을 활용한 추천 메뉴 및 관심 메뉴 이미지 생성 <br><br>|
| (4) 기대효과 및 의의 | <br>한국에 머무르는 외국인들이 한식에 대한 정보 접근성을 크게 향상시킬 수 있다. 특히, dietary restrictions을 가진 사람들에게는 자신에게 적합한 음식을 안전하게 선택할 수 있는 도구를 제공하여 불안감을 해소하고, 메뉴 선택의 자율성을 확대해준다. 메뉴 설명과 밑반찬 정보 제공으로 인해 한국 음식 문화에 대한 이해가 높아진다. 이로써 외국인들이 한국 생활에 적응하는 과정이 더욱 원활해질 것이다. 나아가, 한식 메뉴 추천 기능을 통해 다양한 음식을 시도할 기회를 제공함으로써 외국인들이 한국 음식 문화를 즐기고 그에 대한 긍정적인 경험을 쌓도록 돕는다. 이는 결과적으로 한국 생활에 대한 진입장벽을 낮추고, 더 많은 외국인들이 한국에서의 생활에 긍정적인 인식을 가지도록 기여할 것이다.<br><br> |
| (5) 주요 기능 리스트 | <br>FoodieBuddy의 주요 기능은 총 **5가지**이다. 각 기능을 **기능Ⓐ ~ 기능Ⓔ**로 칭하며 그에 대해 기술하고자 한다. <br><br> **[기능Ⓐ : Dietary restrictions 입력]** <br> 사용자가 자신의 dietary restriction을 입력할 수 있다. 입력한 dietary restriction 정보는 데이터베이스에 저장된 후 챗봇의 프롬프트에 포함되어, 사용자는 항상 자신의 dietary restriction에 대한 고려가 포함된 챗봇 답변을 얻을 수 있다. <br><br> **[기능Ⓑ : 한식 메뉴 추천]** <br>Gpt-4o가 프롬프트의 설명에 따라 단계적으로 한식 메뉴 추천을 위한 대화를 진행한다. 먼저, gpt-4o가 어떠한 음식이 먹고싶은지 사용자에게 질문을 하고, 사용자가 답변하면, 이와 함께 dietary restrictions 정보를 함께 고려하여 메뉴를 추천한다. 이때, 정확도 향상을 위해 농촌진흥청의 식재료 데이터 API를 통해 얻은 식재료 정보를 gpt-4o의 프롬프트로 추가 제공한다. 대화 중 사용자에게 추천할 메뉴에 대해서는 stable diffusion을 통해 해당 메뉴의 이미지를 생성한다. <br><br> **[기능Ⓒ : 메뉴판 사진 설명]** <br>메뉴판 사진을 업로드하면, gpt-4o가 사진을 인식하여, 프롬프트의 설명에 따라 단계적으로 대화를 진행한다. 먼저, gpt-4o가 사진 속 메뉴명을 추출하고, 각 발음 기호(Mul-naengmyeon)와 함께, 의역된 표현(Bukwheat noodles)으로 메뉴명을 안내한다. 대화 중 사용자가 궁금해하는 메뉴가 있다고 말하면, gpt-4o가 사용자 dietary restrictions과 관련하여 해당 메뉴에 대한 상세 설명을 제공하며, stable diffusion이 해당 메뉴의 이미지를 생성한다. 이때 정확도 향상을 위해 농촌진흥청의 식재료 데이터 API를 통해 얻은 식재료 정보를 gpt-4o의 프롬프트로 추가 제공한다. <br><br> **[기능Ⓓ : 밑반찬 사진 설명]** <br>밑반찬 사진을 업로드하면 gpt-4o가 사진을 인식하여, 프롬프트의 설명에 따라 밑반찬 설명을 위한 대화를 진행한다. 이때, 사용자의 dietary restrictions에 관련한 정보를 중점적으로 안내한다. <br><br> **[기능Ⓔ : 메뉴 북마크 및 별점 저장]** <br> 메뉴 추천, 메뉴판 설명, 밑반찬 설명의 과정에서 챗봇이 제공하는 음식 정보를 북마크할 수 있다. 채팅 화면에서 음식 정보가 보여질 때, 옆에 있는 버튼을 누르면 별도의 북마크 목록에 저장되며, 백엔드 서버로 해당 메뉴에 대한 북마크 저장 요청을 보내게 된다. 요청을 받은 백엔드 서버에서는, 해당 유저가 해당 메뉴에 대해 북마크를 저장한 것으로 북마크 저장 기록을 생성한다. 이렇게 저장된 북마크 기록은 북마크 목록에서 한꺼번에 확인할 수 있으며, 북마크를 삭제하거나 북마크로 저장한 각 음식에 대한 별점을 매기는 것도 이 화면에서 가능하다.<br><br>  |

<br>
 
# Project-Design & Implementation
| 항목 | 내용 |
|:---  |---  |
| (1) 요구사항 정의 | <br> FoodieBuddy 앱 서비스의 주요 기능은 크게 Dietary restrictions 입력 기능, 한식 메뉴 추천 기능, 메뉴판 사진 설명 기능, 밑반찬 사진 설명 기능, 메뉴 북마크 및 별점 저장 기능으로 총 5가지이다. <br> 5가지 기능에 대해 <br>**1. 기능별 상세 요구사항**에서 각 기능의 입출력 처리과정을 다루고, 이어서 <br>**2. E-R 다이어그램**을 통해 앱 서비스의 전반적인 데이터가 어떻게 연결되는지를 보이고자 한다. <br><br> **[1. 기능별 상세 요구사항]** <br> <img src="https://github.com/Powerful-Unicorn/.github/blob/2ff45251cbb61477eb25c7a2ee5514c923936a1c/2%EC%B0%A8%EB%B3%B4%EA%B3%A0%EC%84%9C/image/%E1%84%8C%E1%85%AE%E1%84%8B%E1%85%AD%20%E1%84%80%E1%85%B5%E1%84%82%E1%85%B3%E1%86%BC_p1.png" alt="" width="1000" /> <img src="https://github.com/Powerful-Unicorn/.github/blob/2ff45251cbb61477eb25c7a2ee5514c923936a1c/2%EC%B0%A8%EB%B3%B4%EA%B3%A0%EC%84%9C/image/%E1%84%8C%E1%85%AE%E1%84%8B%E1%85%AD%20%E1%84%80%E1%85%B5%E1%84%82%E1%85%B3%E1%86%BC_p2.png" alt="" width="1000" /> <br><br> **[2. E-R 다이어그램]**  <br>이 E-R 다이어그램은 FoodieBuddy 서비스에서 **사용자와 관련된 데이터**, 챗봇과 사용자의 **대화 기록 저장과 관련된 데이터**, **사용자가 메뉴에 대해 저장한 데이터**를 관리하기 위한 테이블 구조를 나타낸다. 이미지 아래에 이어지는 설명은 테이블들 간의 관계와 각 테이블에 저장되는 속성들이 무엇인지에 대한 내용이다. <img src="https://github.com/Powerful-Unicorn/.github/blob/ecce92596836fa94a00fb7e546fd197076334993/1%EC%B0%A8%EB%B3%B4%EA%B3%A0%EC%84%9C/image/E-R%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7.png" alt="E-R diagram" width="1000" /><br><br>**• `user` 테이블**<br>**설명**: 사용자의 기본 정보를 저장하는 테이블이다. 이 테이블에는 사용자의 이메일, 비밀번호, 사용자명, 종교, 식습관 정보(채식 여부, 고기, 달걀, 유제품, 해산물, 견과류, 글루텐, 과일, 채소, 기타 식이 제한 사항)가 포함된다.<br>**주요 필드**:<br>`email`, `password`, `username`: 사용자의 기본적인 정보<br>`religion`, `vegetarian`, `meat`, `egg`, `dairy`, `seafood`, `nut`, `gluten`, `fruit`, `vegetable`, `other`: 사용자의 dietary restriction과 관련된 정보<br><br>**• `chatflow` 테이블**<br>**설명**: 사용자가 진행하는 대화 흐름을 기록하는 테이블이다. 사용자가 대화를 시작하고 완료하는 과정에 대한 정보를 저장한다. <br>**주요 필드**:<br>`chatflow_type`: 대화의 유형 (메뉴 추천, 메뉴판 인식, 반찬 사진 인식의 세 종류 존재)<br>`is_completed`: 완료된 채팅인지 여부<br>`completed_at`: (완료된 채팅인 경우) 완료된 시각<br>`user_id`: 대화를 진행한 사용자의 ID (`chatflow` 테이블은 `user` 테이블과 연결되며, 한 명의 `user`가 여러 개의 `chatflow`를 가질 수 있는 구조이다.)<br><br>**• `user_msg` 테이블**<br>**설명**: 사용자가 보낸 메시지를 저장하는 테이블이다. <br>**주요 필드**:<br>`content`: 사용자가 보낸 메시지 내용<br>`created_at`: 메시지가 생성된 시간<br>`chatflow_id`: 메시지가 속한 chatflow의 ID (`user_msg`테이블은 `chatflow` 테이블과 연결되며, 하나의 `chatflow`에 여러 개의 `user_msg`가 연결될 수 있는 구조이다.)<br><br>**• `chatbot_msg` 테이블**<br>**설명**: 챗봇이 보낸 메시지를 저장하는 테이블이다. <br>**주요 필드**:<br>`content`: 챗봇이 보낸 메시지 내용<br>`created_at`: 메시지가 생성된 시간<br>`user_msg_id`: 사용자의 메시지 ID (`chatbot_msg`은 `user_msg` 테이블과 연결되며, 하나의 `user_msg` 당 하나의 `chatbot_msg`가 연결되는 구조이다. 즉, 유저가 보낸 메시지 하나 당 AI가 응답 하나를 생성하는 구조이다.)<br><br>**• `menu` 테이블**<br>**설명**: 사용자가 별점이나 북마크를 저장한 메뉴를 저장하는 테이블이다.<br>**주요 필드**:<br>`name`: 메뉴 이름<br>`pronunciation`: 메뉴 발음 정보 <br>`star`: 사용자가 이 메뉴에 대해 저장한 별점<br>`is_bookmarked`: 사용자가 이 메뉴를 북마크했는지 여부<br>`user_id`: 별점이나 북마크를 저장한 사용자의 ID (`menu` 테이블은 `user` 테이블과 연결되며, 한 명의 `user`가 여러 개의 `menu` 와 연결될 수 있는 구조이다. 즉, 한 명의 유저가 별점 및 북마크 기록을 여러 개 저장하는 기능을 위한 구조이다.) <br><br> <!-- **[API 명세서]** <br><img src="https://github.com/Powerful-Unicorn/.github/blob/82ceac4709cd5236092756d70451ce970977bc3c/1%EC%B0%A8%EB%B3%B4%EA%B3%A0%EC%84%9C/image/API%20%E1%84%86%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A6%E1%84%89%E1%85%A5.png" alt="" width="1000" /> --> <br> <!-- <img src="https://github.com/Powerful-Unicorn/.github/blob/2a35faf8fa6e2bbe646eb15792a813b83df4784f/1%EC%B0%A8%EB%B3%B4%EA%B3%A0%EC%84%9C/image/flow%20chart/1.%20%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%8B%E1%85%B5%E1%86%AB%20%3A%20%E1%84%92%E1%85%AC%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%80%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A9%E1%84%8B%E1%85%AE.png" alt="" width="25%" /><img src="https://github.com/Powerful-Unicorn/.github/blob/2a35faf8fa6e2bbe646eb15792a813b83df4784f/1%EC%B0%A8%EB%B3%B4%EA%B3%A0%EC%84%9C/image/flow%20chart/2.%20%E1%84%87%E1%85%A1%E1%86%AB%E1%84%8E%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%89%E1%85%B5%E1%86%A8%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%86%E1%85%A7%E1%86%BC%20%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A9%E1%84%8B%E1%85%AE.png" alt="" width="25%" /> <br> <img src="https://github.com/Powerful-Unicorn/.github/blob/2a35faf8fa6e2bbe646eb15792a813b83df4784f/1%EC%B0%A8%EB%B3%B4%EA%B3%A0%EC%84%9C/image/flow%20chart/3.%20%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%20%E1%84%8E%E1%85%AE%E1%84%8E%E1%85%A5%E1%86%AB%20%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A9%E1%84%8B%E1%85%AE.png" alt="" width="25%" /><img src="https://github.com/Powerful-Unicorn/.github/blob/2a35faf8fa6e2bbe646eb15792a813b83df4784f/1%EC%B0%A8%EB%B3%B4%EA%B3%A0%EC%84%9C/image/flow%20chart/4.%20%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%91%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%89%E1%85%B5%E1%86%A8%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8C%E1%85%AE%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A9%E1%84%8B%E1%85%AE.png" alt="" width="25%" /> <br> <img src="" alt="" width="%" /> -->   |
| (2) 전체 시스템 구성 | <br>Foodiebuddy 앱 서비스의 **전체 SW 구조**는 다음 그림과 같다. 그림 하단에 이어지는 내용에서는, 전체 SW 구조를 나눈 3가지 **모듈**에 대한 설명, 3가지 모듈을 다시 나눈 **서브모듈**에 대한 설명, **서브모듈 간 데이터의 흐름**에 대한 설명 순으로 FoodieBuddy의 SW 구조에 대해 기술하고자 한다. <br> <br> <img src="https://github.com/Powerful-Unicorn/.github/blob/5af95acd3716a4aca7493bbbd9910f6d89457c1d/2%EC%B0%A8%EB%B3%B4%EA%B3%A0%EC%84%9C/image/%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%83%E1%85%A9_2%E1%84%8E%E1%85%A1%E1%84%87%E1%85%A9%E1%84%80%E1%85%A9%E1%84%89%E1%85%A5.png" alt="" width="1000" /> <br><br>Foodiebuddy 앱 서비스의 전체 SW 구조는 우선 크게 **세 단위**로 나뉜다. 이를 **모듈 1, 2, 3**이라고 칭하였다. 각 모듈은 다시 **작은 단위**로 나눌 수 있다. 이를 **서브모듈 1-1, 1-2, …** 라고 칭하였다. (각 모듈과 서브모듈의 구현방식에 대한 보다 자세한 설명은 다음 항목인 *(3) 주요엔진 및 기능 설계* 에서 이어질 예정이다.) <br><br> **[모듈]**<br>모듈 1, 2, 3은 아래와 같이 나뉜다.  <br> **• 모듈 1: Frontend** <br>사용자 인터페이스(스마트폰)와 유저와의 직접적인 상호작용을 담당하는 모듈이다. <br> **• 모듈 2: DB서버** <br>DB 접근을 담당하는 모듈이다. 이 모듈은 dietary restriction 정보, 메뉴 북마크 및 별점 정보를 DB에 저장, 조회, 수정, 삭제 하는 로직을 담당한다.  <br> **• 모듈 3: 채팅서버** <br>채팅기능을 담당하는 모듈이다. 이 모듈은 사용자의 메세지와 이미지를 받아 답변을 생성하는 GPT-4o, 음식 이미지를 생성하는 Stable Diffusion, 식재료 데이터 API를 호출하는 로직을 담당한다. 빠른 응답이 중요한 챗봇의 구현을 위해 FastAPI를 채택하며 DB서버와 분리하였다. <br><br><br><br> **[서브모듈]**<br>앞서 설명한 **모듈 1**은 다시 아래와 같이 나뉜다. <br> **• 서브모듈 1-1: Dietary restriction 저장 기능** <br>Dietary restriction 저장 기능과 관련된 UI 및 http 통신을 담당하는 서브모듈이다. 이 서브모듈은 UI를 통해 사용자의 dietary restriction 정보를 입력받고, 이 내용을 http 형식에 맞게 변환하여 백엔드 서버와 통신하는 역할을 담당한다.<br> **• 서브모듈 1-2: 채팅 기능** <br>채팅으로 이루어지는 기능(메뉴 추천, 메뉴판 사진 설명, 밑반찬 사진 설명)과 관련된 UI 및 WebSocket 통신을 담당하는 서브모듈이다. 이 서브모듈은 채팅 UI를 통해 사용자의 요청을 받고, 이 내용을 WebSocket 형식에 맞게 변환하여 백엔드 서버와 통신하는 역할을 담당한다.<br> **• 서브모듈 1-3: 메뉴 북마크 및 별점 기능** <br>메뉴 북마크 및 별점 기능과 관련된 UI 및 http 통신을 담당하는 서브모듈이다. 이 서브모듈은 UI를 통해 사용자의 메뉴 북마크 및 별점 정보를 입력받고, 이 내용을 http 형식에 맞게 변환하여 백엔드 서버와 통신하는 역할을 담당한다. <br><br>앞서 설명한 **모듈 2**는 다시 아래와 같이 나뉜다. <br> **• 서브모듈 2-1: Springboot 서버** <br>Springboot 환경의 어플리케이션이 Amazon EC2 인스턴스에서 실행되고 있는 서브모듈이다. 이 서브모듈은 사용자의 dietary restriction 정보나 메뉴 북마크 및 별점 정보에 대한 저장, 조회, 수정, 삭제 요청이 들어오면, 요청의 내용에 맞게 MySQL 데이터베이스에 접근하는 역할을 담당한다. <br> **• 서브모듈 2-2: MySQL 데이터베이스** <br>MySQL 데이터베이스가 Amazon RDS 인스턴스에 저장되어있는 서브모듈이다. 이 서브모듈은 관계형 데이터베이스의 형식으로 데이터를 저장하는 저장공간의 역할을 담당한다. <br><br>앞서 설명한 **모듈 3**은 다시 아래와 같이 나뉜다. <br> **• 서브모듈 3-1: FastAPI 서버** <br>FastAPI 환경의 어플리케이션이 Amazon EC2 인스턴스에서 실행되고 있는 서브모듈이다. 이 서브모듈은 프론트엔드로부터 받은 메시지의 내용에 맞게 필요한 모델(GPT-4o 또는 Stable Diffusion)을 호출하는 역할을 담당한다. <br> **• 서브모듈 3-2: GPT-4o** <br>챗봇의 채팅 응답 생성이 필요할 때 서브모듈 3-1에 의해 호출되는 서브모듈이다. 이 서브모듈은 서브모듈 3-1로부터 인자로 전달받은 유저 메시지의 내용에 따라 유저에게 필요한 정보를 담은 채팅 응답을 생성하는 역할을 담당한다. 이때, 서브모듈 3-4를 호출하여 받은 응답의 내용을 이용하여 정확도 높은 정보를 제공한다. <br> **• 서브모듈 3-3: Fine tuned Stable Diffusion** <br>이미지 생성이 필요할 때 서브모듈 3-1에 의해 호출되는 서브모듈이다. 이 서브모듈은 서브모듈 3-1로부터 인자로 전달받은 한식 메뉴명에 따라 이미지를 생성하는 역할을 담당한다. <br> **• 서브모듈 3-4: 식재료 데이터 API** <br>채팅 응답이 생성될 때, 응답의 정확도를 높이기 위해 서브모듈 3-2에 의해 호출되는 서브모듈이다. 이 서브모듈은 서브모듈 3-1로부터 인자로 전달받은 한식 메뉴명에 대한 재료 정보를 제공하는 역할을 담당한다. <br><br><br><br><br> **[서브모듈 간 데이터의 흐름]** <br><br> **기능 Ⓐ (dietary restriction 입력)에서의 데이터 흐름** <br><img src="https://github.com/Powerful-Unicorn/.github/blob/d3a270d596187084646daca654f13a1d015ebd57/2%EC%B0%A8%EB%B3%B4%EA%B3%A0%EC%84%9C/image/a.png" alt="" width="1000" /><br> **(1) User → Frontend** <br>UI에서 텍스트 입력란과 체크박스를 이용하여, 자신의 dietary restriction 정보를 입력한다. <br> **(2) Frontend → Springboot 서버** <br>http 통신을 통해, dieatary restriciton 정보 (json 형식의 텍스트 데이터)를 전송<br> **(3) Springboot 서버 → MySQL 데이터베이스** <br>DB서버에서, json 형식의 텍스트 데이터 → 자바 객체 형식으로 변환 후 자바 객체의 내용에 맞는 MySQL 쿼리가 생성된다. (즉, json → 자바 객체 → MySQL 테이블)<br> **(4) MySQL 데이터베이스 → GPT-4o** <br>채팅 서버에서 요청시, MySQL 테이블에 존재하는 정보가, json 형식의 텍스트 데이터로 반환된다. 이를 파싱하여, gpt에게 프롬프팅의 일부로 전달한다.<br><br><br> **기능 Ⓑ (한식 메뉴 추천 채팅)에서의 데이터 흐름** <br> <img src="https://github.com/Powerful-Unicorn/.github/blob/aa80a3162ca2c8551a38b84ac84140527ed939cb/2%EC%B0%A8%EB%B3%B4%EA%B3%A0%EC%84%9C/image/b.png" alt="" width="1000" /><br> **(1) User → Frontend** <br>어떤 맛이나 느낌의 음식을 원하는지(예: “spicy and warm”)를 채팅UI를 통해 입력한다.<br> **(2) Frontend → FastAPI 서버** <br>서버의 메뉴 추천 채팅 플로우로 연결되는 URI 경로 ‘recommendation’ 로 웹소켓 통신을 initiate한다. URI 경로의 string 값에 따라, 서버에서는 ‘메뉴 추천’ 플로우를 시작한다. 생성된 웹소켓 통신을 통해, 유저의 메시지(텍스트 데이터)와 GPT의 답변(텍스트 데이터)이 오고간다. 이미지 전송이 있는 경우에도 마찬가지로 웹소켓 통신을 통해 이미지(바이너리 형식으로 인코딩된 데이터)가 전달된다.<br> **(3) FastAPI 서버 → GPT-4o** <br>URI 경로의 string 값에 따라, ‘메뉴 추천’ 플로우에 맞는 프롬프팅(텍스트 데이터)과 사용자 메시지(텍스트 데이터)를 인자로 GPT를 호출한다. 호출된 GPT는 응답 메시지(텍스트 데이터)를 리턴한다.<br> **(4) FastAPI 서버 → Stable Diffusion** <br>GPT의 응답 중 음식명(텍스트 데이터)을 파싱하여 인자로 Stable Diffusion 호출한다. 호출된 Stable Diffusion은 생성한 이미지(바이너리 형식으로 인코딩된 데이터)를 리턴한다.<br> **(5) 식재료API → GPT-4o** <br>GPT의 응답 중, 음식명(텍스트 데이터)을 파싱하여 인자로 식재료 데이터 API를 호출한다. 호출된 API는 식재료 데이터(json 형식의 텍스트 데이터)를 리턴한다. 이 json 형식의 텍스트 데이터를, 식재료 정보 위주로 파싱하여 GPT 호출 시 전달되는 프롬프팅에 포함시킨다.<br><br><br> **기능 Ⓒ (메뉴판 설명 채팅)에서의 데이터 흐름**<br><img src="https://github.com/Powerful-Unicorn/.github/blob/d3a270d596187084646daca654f13a1d015ebd57/2%EC%B0%A8%EB%B3%B4%EA%B3%A0%EC%84%9C/image/c.png" alt="" width="1000" /> <br> **(1) User → Frontend** <br>설명을 얻고자 하는 메뉴판의 사진을 채팅UI를 통해 전송한다. FE에서는 이미지 파일을 base64 형식으로 인코딩하여 텍스트 데이터로 변환하는 과정을 거친다.<br> **(2) Frontend → FastAPI 서버**<br>서버의 메뉴판 설명 채팅 플로우로 연결되는 URI 경로 ‘askmenu’ 로 웹소켓 통신을 initiate한다. 생성된 웹소켓 통신을 통해, 메뉴판 사진(이미지 파일을 base64로 인코딩한 텍스트 데이터)를 전송한다. URI 경로의 string 값에 따라, 서버에서는 ‘메뉴판 설명’ 플로우를 시작한다. 생성된 웹소켓 통신을 통해, 유저의 메시지(텍스트 데이터)와 GPT의 답변(텍스트 데이터)이 오고간다. 이미지 전송이 있는 경우에도 마찬가지로 웹소켓 통신을 통해 이미지(바이너리 형식으로 인코딩된 데이터)가 전달된다.<br> **(3) FastAPI 서버 → GPT-4o** <br>URI 경로의 string 값에 따라, ‘메뉴판 설명’ 플로우에 맞는 프롬프팅(텍스트 데이터)과 사용자가 보낸 메뉴판 사진(이미지 파일을 base64로 인코딩한 텍스트 데이터)를 인자로 GPT를 호출한다. 호출된 GPT는 응답 메시지(텍스트 데이터)를 리턴한다.<br> **(4) FastAPI 서버 → Stable Diffusion** <br>GPT의 응답 중 음식명(텍스트 데이터)을 파싱하여 인자로 Stable Diffusion 모델을 실행한다. Stable Diffusion은 생성한 이미지(바이너리 형식으로 인코딩된 데이터)를 리턴한다.<br> **(5) 식재료API → GPT-4o** <br>GPT의 응답 중, 음식명(텍스트 데이터)을 파싱하여 인자로 식재료 데이터 API를 호출한다. 호출된 API는 식재료 데이터(json 형식의 텍스트 데이터)를 리턴한다. 이 json 형식의 텍스트 데이터 중, 식재료 정보를 파싱하여 GPT 호출 시 전달되는 프롬프팅에 포함시킨다.<br><br><br> **기능 Ⓓ (밑반찬 설명)에서의 데이터 흐름** <br><img src="https://github.com/Powerful-Unicorn/.github/blob/d3a270d596187084646daca654f13a1d015ebd57/2%EC%B0%A8%EB%B3%B4%EA%B3%A0%EC%84%9C/image/d.png" alt="" width="1000" /><br> **(1) User → Frontend** <br>설명을 얻고자 하는 밑반찬의 사진을 채팅UI를 통해 전송한다. FE에서는 이미지 파일을 base64 형식으로 인코딩하여 텍스트 데이터로 변환하는 과정을 거친다.<br> **(2) Frontend → FastAPI 서버** <br>서버의 밑반찬 설명 채팅 플로우로 연결되는 URI 경로 ‘askdish’ 로 웹소켓 통신을 initiate한다. 생성된 웹소켓 통신을 통해, 밑반찬 사진(이미지 파일을 base64로 인코딩한 텍스트 데이터)를 전송한다. URI 경로의 string 값에 따라, 서버에서는 ‘밑반찬 설명’ 플로우를 시작한다. 생성된 웹소켓 통신을 통해, 유저의 메시지(텍스트 데이터)와 GPT의 답변(텍스트 데이터)이 오고간다.<br> **(3) FastAPI 서버 → GPT-4o** <br>URI 경로의 string 값에 따라, ‘밑반찬 설명’ 플로우에 맞는 프롬프팅(텍스트 데이터)과 사용자가 보낸 밑반찬 사진(이미지 파일을 base64로 인코딩한 텍스트 데이터)를 인자로 GPT를 호출한다. 호출된 GPT는 응답 메시지(텍스트 데이터)를 리턴한다.<br> **(4) 식재료API → GPT-4o** <br>GPT의 응답 중, 음식명(텍스트 데이터)을 파싱하여 인자로 식재료 데이터 API를 호출한다. 호출된 API는 식재료 데이터(json 형식의 텍스트 데이터)를 리턴한다. 이 json 형식의 텍스트 데이터 중, 식재료 정보를 파싱하여 GPT 호출 시 전달되는 프롬프팅에 포함시킨다.<br><br><br> **기능 Ⓔ (메뉴 북마크 및 별점)에서의 데이터 흐름**<br><img src="https://github.com/Powerful-Unicorn/.github/blob/d3a270d596187084646daca654f13a1d015ebd57/2%EC%B0%A8%EB%B3%B4%EA%B3%A0%EC%84%9C/image/e.png" alt="" width="1000" /> <br> **(1) User → Frontend** <br>UI에서 북마크 버튼과 별점 버튼을 이용하여, 메뉴에 대한 북마크여부와 별점 개수를 입력한다.<br> **(2) Frontend → Springboot 서버** <br>http 통신을 통해, ‘메뉴id’, ‘북마크 여부’, ‘별점 개수’의 3가지 정보(json 형식의 텍스트 데이터)를 전송한다.<br> **(3) Springboot 서버 → MySQL 데이터베이스** <br>DB서버에서, json 형식의 텍스트 데이터 → 자바 객체 형식으로 변환 후 자바 객체의 내용에 맞는 MySQL 쿼리가 생성된다. (즉, json → 자바 객체 → MySQL 테이블)<br> **(4) MySQL 데이터베이스 → GPT-4o** <br>채팅 서버에서 요청시, MySQL 테이블에 존재하는 정보가, json 형식의 텍스트 데이터로 반환된다. 유사한 dietary restriction을 가진 유저들의 북마크 및 별점 정보를, user based collaborative filtering을 적용하여 메뉴 추천에 반영할 예정이다.<br><br> |
| (3) 주요엔진 및 기능 설계 | <br> 이 항목에서는 앞서 설명한 기준으로 구분된 모듈1, 모듈2, 모듈3 각각의 **구현 내용 및 방법**에 대해 설명하고자 한다. 또한, 각 모듈의 구현에 대해 기술할 때, 모듈이 받는 **input**,  모듈의 **내부 로직**, 모듈이 내보내는 **output**의 3가지 관점으로 나누어 서술하고자 한다.  <br><br><br> **1. 모듈1-Frontend의 구현 내용 및 방법** <br><br> **[서브모듈 1-1 : 사용자의 dietary restrictions 입력]** <br> **`input`:** <br>사용자가 UI를 통해 dietary restriction 정보를 입력한다. <br> **`내부 로직`:** <br>UI를 통해 입력된 dietary restriction 정보를 json형식으로 변환하여 DB서버로 http요청을 보내고 응답을 받는다. 이때 Dietary restriction 입력과정은 두 단계에 걸쳐 진행되며, 첫번째 단계(종교, 채식 등의 정보 입력)에서 받은 http응답의 내용을 반영한 UI를 통해 두번째 단계(못 먹는 재료 입력)의 입력을 받는다. 최종적으로, 두번째 단계에서 받은 입력까지 반영한 내용으로 저장할 것을 http요청으로 보낸다. <br> **`output`:** <br>첫번째 단계의 입력내용이 두번째 단계의 입력 UI에 반영되어 나타난다. 또한 사용자는 입력한 dietary restricions이 항상 반영된 정보와 서비스를 제공받게 된다.  <br><br> **[서브모듈 1-2 : 채팅 기능 (한식 메뉴 추천 / 메뉴판 설명 / 밑반찬 설명)]** <br> **`input`:** <br>사용자가 자신의 음식 취향이 포함된 채팅 메시지를 전송(기능Ⓑ : 한식 메뉴 추천)하거나 설명을 얻고자 하는 이미지를 전송(기능Ⓒ : 메뉴판 설명 기능, 기능Ⓓ : 밑반찬 설명 기능)한다.<br> **`내부 로직`:** <br>세가지 기능 중 어떤 기능을 위한 채팅인지에 대한 정보를 포함하여 WebSocket 연결 생성 요청을 채팅서버로 보낸다. WebSocket 연결이 생성된 후에는 연결이 지속되며 서버와 실시간으로 데이터를 주고받게 된다. 또한, 사용자가 이미지 데이터를 전송한 경우에는 이를 바이너리 데이터로 인코딩 하는 과정을 WebSocket 전송 전에 거친다.<br> **`output`:** <br>한식 메뉴 추천 기능(기능Ⓑ)의 경우, 사용자의 음식 취향과 dietary restriction이 반영하여 추천된 메뉴에 대한 설명과 음식 사진을, 메뉴판 설명 기능(기능Ⓒ)과 밑반찬 설명 기능(기능Ⓓ)의 경우, 사진에 대한 설명과 dietary restriction 관련 정보을, 채팅 UI를 통해 output으로 제공한다.  <br><br> **[서브모듈 1-3 : 메뉴 북마크 및 별점 기능]** <br> **`input`:** <br>사용자가 북마크 아이콘을 눌러 메뉴를 저장하고, 별점 아이콘을 눌러 별점을 메긴다. <br> **`내부 로직`:** <br>사용자id와 메뉴id, 부여한 별점 개수를 http 통신에 맞는 형식으로 변환하여 DB서버로 저장 요청을 보낸다. 또한, 사용자가 북마크 조회 화면을 실행하면 DB서버로 조회 요청을 보내고 응답을 받는다.<br> **`output`:** <br>어떤 메뉴를 북마크했고 몇 점의 별점을 부여했는지의 기록을, 북마크 조회화면 UI를 통해 output으로 제공한다.  <br><br><br><br><br> **2. 모듈2-DB서버의 구현 내용 및 방법** <br><br> **[서브모듈 2-1 : Springboot 서버]** <br> **`input`:** <br>프론트엔드(모듈1)로부터 http 요청이 들어온다.<br> **`내부로직`:** <br>들어온 http 요청의 종류와 내용에 따라, 응답을 제공하기 위한 MySQL 쿼리가 생성된다. 생성된 쿼리를 MySQL 데이터베이스(서브모듈 2-2)로 보내서 받은 응답을 http 응답 형식에 맞게 변환한다. <br> **`output`:** 프론트엔드(모듈1)에게 http 응답을 전송한다. <br><br> **[서브모듈 2-2 : MySQL 데이터베이스]** <br> **`input`:** <br>Springboot 서버(서브모듈 2-1)로부터 조회, 저장, 수정, 삭제 쿼리(MySQL)가 요청된다. <br> **`내부로직`:** <br>조회, 저장, 수정, 삭제 쿼리에 맞게 데이터베이스에 접근한다. <br> **`output`:** <br>쿼리를 수행한 결과를 Springboot 서버(서브모듈 2-1)에게 응답으로 보낸다.  <br><br><br><br><br> **3. 모듈3-채팅서버의 구현 내용 및 방법** <br><br> **[서브모듈 3-1 : FastAPI 서버]** <br> **`input`:** <br>프론트엔드(모듈1)로부터 WebSocket연결 생성 요청 및 입력 데이터가 들어온다.<br> **`내부로직`:** <br>WebSocket연결 생성 요청이 들어오면 연결을 생성한다. 이렇게 연결이 생성되는 시점에, 세가지 채팅 기능 중 어떤 기능을 위한 채팅인지에 따라 세가지 다른 함수 중 알맞은 함수를 호출한다. 채팅 응답 생성을 위해서는 GPT-4o를, 이미지 응답 생성을 위해서는 Stable Diffusion을 호출하여 응답을 받는다. <br> **`output`:** <br>GPT-4o 또는 Stable Diffusion로부터 받은 응답을 WebSocket연결을 통해 프론트엔드(모듈1)에게 전송한다.  <br><br> **[서브모듈 3-2 : Gpt-4o]** <br> **`input`:** 사용자 입력 메세지(String) 또는 이미지(Base64)가 들어온다.<br> **`내부 로직`** <br> **• 기본 모델 및 대화 히스토리 초기화:** <br> gpt-4o 모델을 사용하여 대화를 수행하며, ChatMessageHistory를 활용하여 대화 메시지를 저장하여 대화의 흐름을 유지한다. (이를 기반으로 모든 대화내용은 저장된다.)<br> **• 대화 프롬프트 생성:** <br> 대화의 전반적인 흐름을 설정하는 프롬프트로, 음식 이름, 설명 형식, 사용자 질문 처리 방식을 정의한다. 프롬프트는 모듈 2-2로 부터 조회한 사용자의 Dietary restrictions를 포함하여 각 채팅 기능 대화 흐름에 맞춰 작성된다. (실제 프롬프트 내용은 각 기능별로 내용이 다르기에, (4) 주요 기능 구현에서 구체적으로 설명하고자 한다.)<br> **• 프롬프트 템플릿과 체인 생성:** <br> 프롬프트와 히스토리 메시지를 기반으로 대화 흐름을 구성하는 템플릿을 생성한 뒤, 템플릿과 모델을 연결하여 파이프라인(체인)을 구성한다.<br> **• 채팅 진행:** <br> 사용자 입력(String 또는 Base64)을 받은 뒤, 체인에 사용자 입력을 전달하면, 모델의 응답이 반환된다. while true 반복문 안에서, WebSocket 연결이 끊기기 전까지 모델과 지속적인 대화가 진행된다.<br> **• 채팅 진행 중 다른 모듈과의 연결 방식:** <br> 채팅 진행 중 특정 메뉴에 대한 재료 정보가 필요한 경우, [메뉴의 한국어 이름 (영어로 의역한 메뉴 이름)]을 알파벳으로 표기한 형식으로 출력한다. (이러한 출력 형태는 식재료 데이터 API를 활용한 식재료 조회로 이어진다.) 채팅 진행 중 특정 메뉴에 대한 이미지 생성이 필요한 경우, [메뉴의 한국어 이름 (영어로 의역한 메뉴 이름)]을 알파벳으로 표기한 형식으로 출력한다. (이러한 출력 형태는 모듈 3-3의 이미지 생성으로 이어진다.)<br> **`output`:** 모델의 답변(String)이 반환된다. <br><br> **[서브모듈 3-3 : Fine tuned Stable Diffusion]** <br> **`input`:** 음식명(String)이 입력된다.<br> **`내부 로직`** <br> **• 모델 로드와 LoRA 가중치 파일 적용:** <br> Hugging Face Hub에서 LoRA 가중치 파일을 다운로드하고, Stable Diffusion v1-5 모델을 float16 데이터 타입으로 로드하고, cuda(GPU)를 기반으로 실행되도록 파이프라인을 구성하여 필요한 환경을 셋팅한다. 구성한 파이프라인에 모델에 다운로드한 LoRA 가중치를 적용하여 특정 도메인 (한국 음식 이미지)에 맞게 미세 조정된 결과를 생성할 수 있게 한다.<br> **• 텍스트-이미지 생성:** <br> 파이프라인에 텍스트 프롬프트(한국 음식명)를 입력하여 이미지를 생성한다. 생성된 이미지(PIL)를 바이너리 형식으로 변환한다.<br> **`output`:** 이미지(바이너리 데이터)가 반환된다.<br> **`기타`:** 파인튜닝 과정<br> **• 파인튜닝 방식:** <br> 베이스 모델은 stable diffusion v1-5을 활용하였다. LoRA를 활용하여 기존 모델의 가중치를 고정한 채, 새로운 가중치를 추가하여 모델이 한식 이미지를 더 잘 생성할 수 있도록 파인튜닝을 진행하였다. 파인튜닝은 diffusers의 train_text_to_image_lora.py를 활용하였다.(https://github.com/huggingface/diffusers/blob/main/examples/text_to_image/train_text_to_image_lora.py) (최소한의 용량으로 파인튜닝의 효과를 내기 위해 LoRA를 활용하는 방식을 채택하였다.)<br> **• 파인튜닝 데이터:** <br> 데이터는 AI hub의 '한국 이미지(음식)' 데이터셋을 활용하였다.(https://aihub.or.kr/aihubdata/data/view.do?currMenu=115&topMenu=100&dataSetSn=79) 기존 데이터셋에는 약 150종의 한식이 각 1000장씩 포함(약 150,000장)되어 있었다. 그러나 중복되거나 부적절한 음식 이미지가 포함되어 있었기 때문에, 파인튜닝에 적합하도록 143종(유사한 음식 메뉴는 제외하였다.)의 한식을 각 15장씩 선별하였으며, 모든 라벨을 영어로 번역하여 최종 데이터셋을 구성하였다. 새로 생성한 데이터 파일은 HuggingFace Hub에 업로드하였다.(https://huggingface.co/datasets/Jiho0o0/kfood_image_englabel) <br> **• 파인튜닝 완료 후 업로드:** <br> 생성된 LoRA 가중치 파일을 Hugging Face에 업로드하였다.(https://huggingface.co/Jiho0o0/diff_kfood_finetuned/tree/main) <br><br> **[서브모듈 3-4 : Data]** <br> **`input`:** 음식명 (String)이 입력된다. <br> **`내부로직`** <br> **• 모델을 활용한 한글 음식명 변환:** <br> gpt-4o 모델을 사용하여 영어로 입력된 음식명을 한국어 음식명으로 변환한다.<br> **• API 요청으로 재료 정보 가져오기:** <br> 변환된 한국어 음식명을 포함하여 공공 API에 요청을 보낸다.(API: http://apis.data.go.kr/1390802/AgriFood/FdFood/getKoreanFoodFdFoodList) <br> **• XML 데이터 파싱:** <br> API 응답을 XML 형식으로 받아, 해당 XML을 파싱하여 재료 리스트를 추출한다. 재료 정보를 추출할 수 있는 경우, 재료 이름 중 영어 이름만 선택하여 리스트로 만듭니다. 만든 리스트는 String으로 형변환을 통해 최종 반환 내용을 생성한다. 재료 정보를 추출할 수 없는 경우(식재료 데이터 API에 검색하고자 하는 음식에 대한 데이터가 없는 경우), 정보가 없다는 메시지를 반환한다.<br> **`output`:** 식재료 정보(String)가 반환된다. <br><br> |
| (4) 주요 기능의 구현 | <br>이 항목에서는 **핵심 기능 3가지**와 모듈 간의 연관성에 대해 설명하고자 한다. <*Project-Summary*> / *(5) 주요 기능 리스트*에 기술한 5가지 기능 중, 이 서비스의 핵심 기능에 해당하는 **기능Ⓑ, 기능Ⓒ, 기능Ⓓ**는 사용자와 **챗봇** 형태로 상호작용하며, **모듈1(FE)** 과 **모듈3(채팅서버)** 이 핵심적으로 개입한다. 따라서, 각 기능의 구현에 모듈1과 모듈3이 어떻게 연관되어있는지에 대해 서술하고자 한다. 또한, 챗봇 형태로 제공되는 각 기능에서는, 그에 맞는 흐름에 따라 대화가 진행되도록 작성한 **프롬프트**가 핵심적인 역할을 하므로, 이에 비중을 두어 서술하고자 한다.  <br><br>**[기능Ⓑ 한식 메뉴 추천 채팅 기능]** <br><br>**기능Ⓑ에서 모듈1의 역할**<br>사용자는 모듈1을 통해 자신이 어떤 맛이나 느낌의 음식을 먹고싶은지 말한다. 이때, 모듈1의 친숙한 채팅UI는 사용자가 편리하게 내용을 입력할 수 있게 해준다. 모듈1은  WebSocket 통신을 통해 사용자가 입력한 String을 모듈3으로 전송한다. 또한 챗봇의 답변을 받은 이후에도, 사용자는 채팅UI를 통해 상호작용하며 필요한 답변을 얻는 과정을 반복할 수 있다. 만약 모듈3에서 모듈1로 바이너리 타입으로 인코딩된 이미지 파일이 전송된다면, 이를 다시 이미지 파일로 디코딩하여 UI에 보여지게 하는 기능 또한 모듈1에서 담당한다.  <br><br>**기능Ⓑ에서 모듈3의 역할**<br><br>**Gpt-4o(서브모듈 3-2) 프롬프트 내용 요약 :**<br>이 프롬프트는 한식 메뉴를 추천하는 대화의 흐름으로 구성되어 있다. 사용자의 식이 제한 사항 및 사용자의 답변을 고려하여 적절한 요리를 재료 정보, 이미지와 함께 추천하는 방식으로, 아래의 단계를 따라 대화를 진행하라는 설명을 프롬프트로 작성하였다.<br><br>**1단계 : 대화 시작 및 질문**<br>- 사용자가 원하는 요리 유형을 묻고 대화를 시작한다. 사용자의 관심사를 탐색하며, 매운 맛, 순한 맛, 구수한 맛 등 사용자가 원하는 요리의 스타일을 묻는다.<br>**2단계 : 메뉴 추천**<br>- 사용자의 응답과 식이 제한을 바탕으로 추천할 메뉴를 결정한다.<br>- 이때, 모듈 2로부터 식이제한이 유사한 다른 유저가 기능 Ⓔ에서 평가한 내용을 활용한다. (user-based collaborative filtering 결과를 반영한다.)<br>- 추천 메뉴명을 정해진 형식([메뉴의 한국어 이름 (영어로 의역한 메뉴 이름)] 을 알파벳으로 표기한 형식)대로 출력하여 Stable Diffusion(서브모듈 3-3), 식재료API(서브모듈 3-4)로 연결되도록 한다.<br>**3단계 : 메뉴 설명**<br>- 선택된 메뉴에 대한 설명을 제공한다. 메뉴에 대한 기본 정보, 주요 재료, 사용자의 식이 제한에 대한 정보를 포함한 형식을 사용하여 명확하게 전달한다.<br>**4단계 : 추가 메뉴 추천 또는 대화 종료**<br>- 사용자가 추천된 메뉴를 좋아하지 않을 경우 다시 메뉴를 추천하거나, 사용자가 좋아한 경우 대화를 마무리한다.<br><br>위의 프롬프트를 기반으로 아래와 같은 세부 기능들로 한식 메뉴 추천 채팅이 진행된다.<br><br>**1. 추천 메뉴 생성**<br>- 프롬프트에 명시된 1단계, 2단계에 따라 추천 메뉴가 결정된다.<br>**2. 추천 메뉴 이름 번역 및 재료 검색**<br>- 활용하는 식재료 API(서브모듈 3-4)는 한국어로 되어있기에, 결정된 메뉴명을 gpt-4o를 별도로 사용하여 한국어로 번역을 한다.<br>- 이어서, 이 메뉴명에 대해 식재료 데이터 API에서 재료 정보를 검색한다. 검색한 내용은 추가적인 프롬프트 내용으로 Gpt-4o(서브모듈 3-2)에 전달된다.<br>**3. 추천 메뉴 이미지 생성**<br>- 결정된 메뉴명을 파인튜닝된 Stable diffusion(서브모듈 3-3)에 입력으로 전달하여 이미지를 생성한다.<br>- 생성된 이미지는 채팅 화면에 보여진다.<br>**4. 추천 메뉴 설명 및 채팅 진행**<br>- ‘추천 메뉴 이름 번역 및 재료 검색' 이후 업데이트 된 프롬프트 내용을 기반으로 추천 메뉴를 설명한다.<br>- 이어서 사용자의 반응에 따라 추천 메뉴를 다시 생성하거나, 추천 메뉴에 대한 질의 응답을 진행하는 것으로 대화가 진행된다.<br><br>**[기능Ⓒ 메뉴판 설명 기능]**<br><br>**기능Ⓒ에서 모듈1의 역할**<br>사용자는 모듈1을 통해 설명이 필요한 한국어 메뉴판의 사진을 전송한다. 이때, 모듈1의 친숙한 채팅UI는 사용자가 편리하게 내용을 입력할 수 있게 해준다. 모듈1은 이 사진 데이터를 WebSocket 통신을 통해 전송 가능한 형식인 바이너리 타입으로 인코딩하는 과정을 거친 후 모듈3으로 전송한다. 또한 챗봇의 답변을 받은 이후에도, 사용자는 채팅UI를 통해 상호작용하며 필요한 답변을 얻는 과정을 반복할 수 있다. 만약 모듈3에서 모듈1로 바이너리 타입으로 인코딩된 이미지 파일이 전송된다면, 이를 다시 이미지 파일로 디코딩하여 UI에 보여지게 하는 기능 또한 모듈1에서 담당한다. <br><br>**기능Ⓒ에서 모듈3의 역할**<br><br>**Gpt-4o(서브모듈 3-2) 프롬프트 내용 요약:**<br>이 프롬프트는 한식 메뉴판 이미지를 입력받아 사용자의 식이 제한에 맞춰 메뉴를 설명하는 대화의 흐름으로 구성되어 있다. 사용자가 메뉴에서 선택할 수 있는 항목을 이해하고 결정할 수 있도록 재료 정보, 이미지와 함께 설명을 제공하는 방식으로, 아래의 단계에 따라 대화를 진행하라는 설명을 프롬프트로 작성하였다.<br><br>**1단계 : 메뉴판 이미지의 메뉴명 추출**<br>- 입력된 메뉴판 이미지에서 한식 메뉴명만을 추출한다.<br>**2단계 : 메뉴별 한줄 설명 제공**<br>- 추출된 메뉴명에 대하여 각 메뉴별로 한줄씩 간단하게 설명을 제공한다.<br>**3단계 : 관심 메뉴 선정**<br>- 추천 메뉴명을  정해진 형식([메뉴의 한국어 이름 (영어로 의역한 메뉴 이름)] 을 알파벳으로 표기한 형식)대로 출력하여 재료 검색 함수, 이미지 생성 함수 호출로 연결되도록 한다.<br>**4단계 : 관심 메뉴 설명**<br>- 선택된 메뉴에 대한 설명을 제공한다. 메뉴에 대한 기본 정보, 주요 재료, 사용자의 식이 제한에 대한 정보를 포함한 형식을 사용하여 명확하게 전달한다.<br>**5단계 : 추가 설명 및 대화 종료**<br>- 사용자가 또 다른 메뉴를 묻는 경우 그 메뉴에 대해 설명하거나, 사용자가 주문하고 싶은 메뉴를 결정한 경우 대화를 마무리한다.<br><br>위의 프롬프트를 기반으로 아래와 같은 세부 기능들로 한식 메뉴 추천 채팅이 진행된다.<br><br>**1. 메뉴판 이미지의 메뉴별 한줄 설명 제공**<br>- 프롬프트에 명시된 1단계, 2단계에 따라 간단하게 각 메뉴를 설명한다.<br>**2. 관심 메뉴 이름 번역 및 재료 검색**<br>- 활용하는 식재료 API(서브모듈 3-4)는 한국어로 되어있기에, 관심 메뉴명을 gpt-4o를 별도로 사용하여 한국어로 번역을 한다.<br>- 이어서, 이 메뉴명에 대해 식재료 데이터 API에서 재료 정보를 검색한다. 검색한 내용은 추가적인 프롬프트 내용으로 Gpt-4o(서브모듈 3-2)에 전달된다.<br>**3. 관심 메뉴 이미지 생성**<br>- 사용자의 관심 메뉴명을 파인튜닝된 Stable diffusion(서브모델 3-3)에 입력으로 전달하여 이미지를 생성한다.<br>- 생성된 이미지는 채팅 화면에 보여진다.<br>**4. 관심 메뉴 설명 및 채팅 진행**<br>- ‘관심 메뉴 이름 번역 및 재료 검색' 이후 업데이트 된 프롬프트 내용을 기반으로 추천 메뉴를 설명한다.<br>- 이어서 사용자의 반응에 따라 또 다른 관심 메뉴에 대해 설명하거나, 관심 메뉴에 대한 질의 응답을 진행하는 것으로 대화가 진행된다.<br><br>**[기능Ⓓ 밑반찬 설명 기능]**<br><br>**기능Ⓓ에서 모듈1의 역할**<br>사용자는 모듈1을 통해 설명이 필요한 낯선 밑반찬 사진을 전송한다. 이때, 모듈1의 친숙한 채팅UI는 사용자가 편리하게 내용을 입력할 수 있게 해준다. 모듈1은 이 사진 데이터를 WebSocket 통신을 통해 전송 가능한 형식인 바이너리 타입으로 인코딩하는 과정을 거친 후 모듈3으로 전송한다. 또한 챗봇의 답변을 받은 이후에도, 사용자는 채팅UI를 통해 상호작용하며 필요한 답변을 얻는 과정을 반복할 수 있다. 만약 모듈3에서 모듈1로 바이너리 타입으로 인코딩된 이미지 파일이 전송된다면, 이를 다시 이미지 파일로 디코딩하여 UI에 보여지게 하는 기능 또한 모듈1에서 담당한다. <br><br>**기능Ⓓ에서 모듈3의 역할**<br><br>**Gpt-4o(서브모듈 3-2) 프롬프트 내용 요약:**<br>이 프롬프트는 밑반찬 이미지를 입력받아 사용자의 식이 제한에 맞춰 밑반찬을 설명하는 대화의 흐름으로 구성되어 있다. 사용자가 모르는 밑반찬을 먹을 수 있는지 판단할 수 있도록 재료 정보와 함께 설명을 제공하는 방식으로, 아래의 단계에 따라 대화를 진행하라는 설명을 프롬프트로 작성하였다.<br><br>**1단계: 이미지의 밑반찬 이름 출력**<br>- 입력된 이미지에 보이는 밑반찬의 이름을 추출한다.<br>- 이름을 정해진 형식([메뉴의 한국어 이름 (영어로 의역한 메뉴 이름)] 을 알파벳으로 표기한 형식)대로 출력하여 식재료API(서브모듈 3-4)로 연결되도록 한다.<br>**2단계: 밑반찬 설명**<br>- 선택된 메뉴에 대한 설명을 제공한다. 메뉴에 대한 기본 정보, 주요 재료, 사용자의 식이 제한에 대한 정보를 포함한 형식을 사용하여 명확하게 전달한다.<br>**3단계: 추가 설명 및 대화 종료**<br>- 이어서 사용자가 또 다른 밑반찬이 궁금한 경우 다른 밑반찬에 대해 설명하거나, 질문이 있는 경우 해당 밑반찬에 대한 질의 응답을 진행하는 것으로 대화가 진행된다.<br><br>위의 프롬프트를 기반으로 아래와 같은 세부 기능들로 한식 메뉴 추천 채팅이 진행된다.<br><br>**1. 밑반찬 이름 인식**<br>- 프롬프트에 명시된 1단계에 따라 사진에 보이는 밑반찬을 인식한다.<br>**2. 밑반찬 이름 번역 및 재료 검색**<br>- 활용하는 식재료 데이터 API(서브모듈 3-4)는 한국어로 되어있기에, 관심 메뉴명을 gpt-4o(서브모듈 3-2)를 별도로 사용하여 한국어로 번역을 한다.<br>- 이어서, 이 해당 밑반찬에 대해 식재료 데이터 API(서브모듈 3-4)에서 재료 정보를 검색한다. 검색한 내용은 추가적인 프롬프트 내용으로 Gpt-4o(서브모듈 3-2)에 전달된다.<br>**3. 밑반찬 설명 및 채팅 진행**<br>- 이어서 사용자의 반응에 따라 또 다른 밑반찬에 대해 설명하거나, 밑반찬에 대한 질의 응답을 진행하는 것으로 대화가 진행된다.<br><br> |
| (5) 기타 |  |

# Evaluation
| 평가 항목 | 평가 내용 |
|:---  |---  |
| (1) 필요성 | **첫번째**로는, **한식 섭취와 관련된 어려움** 조사하여 **프로젝트의 필요성**을 평가하기 위해 한국에 머물렀거나 머무를 계획이 있는 외국인들을 대상으로 설문을 진행하였다. <br><br>**[평가 방식]** <br>설문 대상: 한국에 머문 경험이 있거나 계획이 있는 외국인 지인 설문 기간: 11/29~12/3 (5일) <br>설문 방법: 구글폼 링크를 인스타그램 DM 으로 전송 <br>응답 결과: 16명 (9개국)  <br><br>**[평가 기준]** <br>1. Dietary restriction 이 있을 때, 섭취 가능한 한식을 판단하는 데 어려움이 있는가? <br>2. 메뉴판을 통해 정보를 얻는 과정에서 어려움이 있는가? <br>3. 밑반찬에 대한 어려움이 있는가? <br><br>**[평가 내용 및 결과]** <br>1. 16명 중 7명이 dietary restriction 이 있다고 답했다. 그 종류는 gluten intolerance (글루텐 불내성), vegan (엄격한 채식주의자), lactose(젖당불내성) 등이 있었다. 본인은 vegetarian (채식주의자) 이지만 한국에서 머무는 동안에는 열악한 환경 때문에 선택적으로 고기를 섭취했다는 답변이 인상적이었다. 채식주의자를 위한 별도의 메뉴가 존재하지 않으며 한식 대부분에는 고기가 포함된다는 것이 그 이유였다. 실제로 dietary restriction 을 가진 사람들이 주변에 많다는 것을 알 수 있었다. 응답자들의 답변은 dietary resctriction 이 한식을 섭취하는 데 실질적인 장애물로 작용했음을 명확히 보여준다. 이는 한국에서의 식사 환경이 특정 dietary resctriction을 가진 이들에게 충분히 친화적이지 않음을 드러내며, 메뉴 구성의 다양성과 정보 제공의 필요성을 시사한다. <br>2. 한국에 방문한 경험이 있다고 답한 7명을 대상으로 한국에서의 식사 경험 어려움에 대해 추가적으로 물었다. 구글 번역기가 낮은 질의 번역을 제공하였다는 답변이 2건, 메뉴판에 사진이 제공되지 않아서 메뉴를 선택하는데 어려움이 있었다는 답변이 2건, 메뉴판에 음식의 조리 방법이나 재료가 상세히 제공되지 않았다는 답변이 1건 있었다. 응답자들이 언급한 구체적 사례는 메뉴판을 통한 정보 획득의 어려움이 분명히 존재함을 나타낸다. 메뉴판에 사진, 재료, 조리 과정 등의 정보가 필요함을 알 수 있다. <br>3. 한식에 대한 이해도와 친숙도를 5점 척도(5: 매우 친숙/ 1:매우 낯섦) 로 물었을 때의 평균은 2.87점으로 낮은 편이었다. 응답자들의 한식 이해도 및 친숙도가 낮은 점은 밑반찬을 포함한 전체적인 한식 경험에 어려움이 있을 수 있음을 암시한다. |
| (2) 프롬프팅 적용 효과 | **두번째**로는, Foodiebuddy의 주요 기술인 채팅 기술에 대하여, Dietary Restrictions를 가진 외국인을 위해한식 정보 제공 채팅이 **프롬프트 적용을 통해 적절히 구현 되었는지** 평가를 진행하였다. <br><br>**[평가 방식]**<br> gpt-4o에 프롬프팅을 적용한 경우와 적용하지 않은 경우에 대해 같은 이미지, 및 내용으로 대화를 진행하하고 이 결과를 비교하였다. 구체적으로는, 주요 채팅 기능 3가지를 모두 비교하였으며, 3가지 기능에 대한 대화 내용이 각 세부 평가 기준에 부합하는지 확인하였다. <br><br>**[평가 기준]** (100점 만점) <br>1. 각 채팅 목적에 맞는 대화를 gpt-4o가 주도적으로 안내 및 진행하는가? (총 45점) <br>1.1 한식 추천 채팅에서, gpt-4o가 주도적으로 한식을 추천하며 대화를 진행하는가? (15점) <br>1.2 메뉴판 설명 채팅에서, gpt-4o가 주도적으로 메뉴판을 설명하며 대화를 진행하는가? (15점) <br>1.3 밑반찬 설명 채팅에서, gpt-4o가 주도적으로 밑반찬을 설명하며 대화를 진행하는가? (15점) <br><br>2. 음식에 대한 설명을 일관된 형식으로 제공하는가? (총 40점) <br>2.1. 특정 음식을 설명할 때, 총 3가지 채팅 기능에서 모두 동일한 형식으로 설명하는가? (30점) <br>2.2. 메뉴판 설명 채팅에서, 메뉴판에 적힌 여러 메뉴에 대한 설명을 일관되게 제공하는가? (10점) <br><br>3. 음식에 대한 설명에서 식재료 정보를 정확하게 제공하는가? (15점) <br><br>**평가 기준에 대한 설명:** <br>타겟 고객은 한식이 낯선 외국인이기에. Foodiebuddy 앱서비스가 대화를 주도하는 것이 필요하다. 이 평가 기준에 대해서는 채팅기능은 3가지로 나뉘므로 각 15점씩 부여하여 총 45점을 할당하였다. <br>또한, 음식을 설명할 때 일관된 형식으로 설명을 제공해야 사용자가 정보를 효율적으로 받아들일 수 있다. 따라서 특정 음식에 대해 설명할 때 총 3가지 채팅 기능을 전반적으로 비교해야하므로 30점, 이 외에 메뉴판 설명 시 여러 메뉴를 간단히 설명하는 부분에 10점을 할당하였다. <br>마지막으로, Dietary Restrictions에 관련한 도움을 주어야하므로, 식재료를 구체적으로 언급하는지에 15점을 할당하였다. <br><br>**[평가 내용 및 결과]**<br>평가 결과에 의하면 프롬프팅을 적용하지 않은 경우는 31점, 프롬프팅을 적용한 경우는 92점으로, 프롬프팅을 적용하는 것이 채팅 기능 구현에 있어서 매우 효과적임을 알 수 있다. 프롬프팅 적용 결과와 그에 대한 구체적인 평가 과정은 아래에서 확인할 수 있다. <img src="https://github.com/Powerful-Unicorn/.github/blob/main/최종보고서/image/프롬프팅 평가 내용.pdf-1.jpg" alt="" width="1000" /><img src="https://github.com/Powerful-Unicorn/.github/blob/main/최종보고서/image/프롬프팅 평가 내용.pdf-2.jpg" alt="" width="1000" /><img src="https://github.com/Powerful-Unicorn/.github/blob/main/최종보고서/image/프롬프팅 평가 내용.pdf-3.jpg" alt="" width="1000" /><img src="https://github.com/Powerful-Unicorn/.github/blob/main/최종보고서/image/프롬프팅 평가 내용.pdf-4.jpg" alt="" width="1000" /><img src="https://github.com/Powerful-Unicorn/.github/blob/main/최종보고서/image/프롬프팅 평가 내용.pdf-5.jpg" alt="" width="1000" /><img src="https://github.com/Powerful-Unicorn/.github/blob/main/최종보고서/image/프롬프팅 평가 내용.pdf-6.jpg" alt="" width="1000" /><img src="https://github.com/Powerful-Unicorn/.github/blob/main/최종보고서/image/프롬프팅 평가 내용.pdf-7.jpg" alt="" width="1000" /><img src="https://github.com/Powerful-Unicorn/.github/blob/main/최종보고서/image/프롬프팅 평가 내용.pdf-8.jpg" alt="" width="1000" /><img src="https://github.com/Powerful-Unicorn/.github/blob/main/최종보고서/image/프롬프팅 평가 결과.pdf-1.jpg" alt="" width="1000" />|
| (3) 파인튜닝 효과 | **세번째**로는, Foodiebuddy의 채팅 기능에서 이미지 생성을 개선하기 위해 적용한 **파인튜닝이 한식 이미지를 비교적 적절히 생성하는지** 평가를 진행하였다. <br><br>**[평가 방식]** <br>베이스 모델인 runwayml/stable-diffusion-v1-5이 생성하는 이미지와, 베이스 모델에 파인튜닝(LoRA 가중치)을 적용하여 생성하는 이미지를 비교하였다. 구체적으로는, 10가지 한식 메뉴에 대해 생성된 이미지를 비교하였다. 10가지 사례에 대해서 각 세부 평가 기준에 부합하는지 확인하였다. <br><br>**[평가 기준]** (100점 만점) 1. 음식을 실제 형태와 유사하게 생성했는가? (총 50점, 각 음식 당 5점) 2. 한식의 문화적 특징(사용 식기 및 식사 환경 등)을 반영했는가? (총 50점 각 음식 당 5점) <br><br>**평가 기준에 대한 설명:** <br>채팅 중 이미지 생성은 사용자의 한식에 대한 이해를 돕기 위함이다. 따라서 실제 형태와 유사하게, 정확하게 이미지를 생성하는 것이 중요하여 50점을 할당하였다. <br>또한, 구이, 찜, 볶음 등 음식 종류에 따라 식사하는 환경 또는 사용되는 식기가 다르기에 이에 대한 정보도 이미지로 확인할 수 있어야 한다. 따라서 이 기준에도 50점을 할당하였다. 10가지 사례가 있으므로, 한 사례 당 각 기준에 대해 5점 만점으로 설정하여 평가를 진행하였다. <br><br>**[평가 내용 및 결과]**<br>평가 결과에 의하면 파인튜닝 적용하지 않은 경우는 39점, 파인튜닝을 적용한 경우는 91점으로, 파인튜닝을 적용하는 것이 한식 이미지 생성에 있어서 매우 효과적임을 알 수 있다. 구체적인 평가 과정은 아래에서 확인할 수 있다.<img src="https://github.com/Powerful-Unicorn/.github/blob/main/최종보고서/image/파인튜닝 평가 내용_결과.pdf-1.jpg" alt="" width="1000" /><img src="https://github.com/Powerful-Unicorn/.github/blob/main/최종보고서/image/파인튜닝 평가 내용_결과.pdf-2.jpg" alt="" width="1000" /><img src="https://github.com/Powerful-Unicorn/.github/blob/main/최종보고서/image/파인튜닝 평가 내용_결과.pdf-3.jpg" alt="" width="1000" /> |
| (4) 만족도 | **네번째**로는, FoodieBuddy 서비스가 **타겟 유저인 외국인들에게 유용한지** 분석하기 위해 설문을 진행하였다.<br><br> **[평가 방식]** <br>설문 대상: 외국인 지인 <br>설문 기간: 11/29~12/3 (5일) <br>설문 방법: 구글폼 링크를 인스타그램 DM 으로 전송. 기능을 설명하는 데모 동영상을 촬영하여 영어 자막을 삽입. <br>응답 결과: 16명 (9개국) <br><br>**[평가 기준]** <br>푸디버디 서비스가 타겟 유저에게 유용한가?  <br><br>**[평가 내용 및 결과]** <br>푸디버디 서비스의 유용성에 대해 5점 척도 (5: 매우 유용 / 1: 유용하지 않음)로 물었을 때의 평균은 4.68 점으로 매우 높았다. 음식 추천 기능의 유용성은 6번, 음식 재료 및 요리에 대한 설명 기능의 유용성은 9번, 한국 요리에 대한 낮은 이해도 극복은 4번 언급되었다. 결론적으로, 푸디버디 서비스는 한국에 머무는 외국인 사용자에게 매우 유용할 수 있음을 확인하였다. |

# Conclusion
| 항목 | 내용 |
|:---  |---  |
| (1) 결론(Conclusion) | 푸디버디는 현재 모든 기능의 개발을 마친 상태이며, 다양한 유즈케이스를 시도해보며 발견되는 버그를 수정하고 성능을 개선하는 등의 리팩토링을 거치는 단계에 있다. 리팩토링 과정을 완료하고 1월 중으로 유저 테스트를 거칠 예정이다. 최종 발표회에서 심사위원님께서 해주신 조언을 반영한 결과, 타겟층은, dietary restriction을 가진 외국인뿐만 아니라, 한식에 대한 정보가 부족하여 이 서비스의 도움을 받을 수 있는 모든 사람들로 확장될 예정이다. 리팩토링과 유저테스트를 거치고 출시가 되면, 푸디버디는 한식에 대한 정보를 얻고자 하는 사람들 누구에게나, 한식 정보에 대한 접근성을 높여줄 수 있는 서비스가 될 것이다. 그 중에서도 특히, deitary restriction을 가진 사람들이 한식을 접할 때, 자신에게 필요한 맞춤형 정보를 손쉽게 얻는 것에 큰 도움이 되어줄 것이다. |

